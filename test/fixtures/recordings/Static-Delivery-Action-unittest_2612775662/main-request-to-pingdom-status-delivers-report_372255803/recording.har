{
  "log": {
    "_recordingName": "Static Delivery Action #unittest/main() request to pingdom status delivers report",
    "creator": {
      "comment": "persister:fs",
      "name": "Polly.JS",
      "version": "2.6.0"
    },
    "entries": [
      {
        "_id": "d1b06285950ec0bbf84ef05dd596c70c",
        "_order": 0,
        "cache": {},
        "request": {
          "bodySize": 0,
          "cookies": [],
          "headers": [
            {
              "name": "host",
              "value": "raw.githubusercontent.com"
            }
          ],
          "headersSize": 122,
          "httpVersion": "HTTP/1.1",
          "method": "GET",
          "queryString": [],
          "url": "https://raw.githubusercontent.com/adobe/helix-static/master/src/index.js"
        },
        "response": {
          "bodySize": 15798,
          "content": {
            "mimeType": "text/plain; charset=utf-8",
            "size": 15798,
            "text": "/*\n * Copyright 2018 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// eslint-disable-next-line import/no-extraneous-dependencies\nconst request = require('request-promise-native');\nconst crypto = require('crypto');\nconst mime = require('mime-types');\nconst postcss = require('postcss');\nconst postcssurl = require('postcss-url');\nconst parser = require('postcss-value-parser');\nconst babel = require('@babel/core');\nconst ohash = require('object-hash');\nconst sanitizer = require('sanitizer');\nconst { wrap } = require('@adobe/helix-pingdom-status');\nconst { logger: setupLogger } = require('@adobe/openwhisk-action-builder/src/logging');\nconst { computeSurrogateKey } = require('@adobe/helix-shared').utils;\n\nconst { space } = postcss.list;\nconst uri = require('uri-js');\n/* eslint-disable no-console */\n\n// one megabyte openwhisk limit + 20% Base64 inflation + safety padding\nconst REDIRECT_LIMIT = 750000;\n\n// global logger\nlet log;\n\n/**\n * Generates an error response\n * @param {string} message - error message\n * @param {number} code - error code.\n * @returns response\n */\nfunction error(message, code = 500) {\n  const statusCode = code === 400 ? 404 : code;\n  log.error('delivering error', message, code);\n  return {\n    statusCode,\n    headers: {\n      'Content-Type': 'text/html',\n      'X-Static': 'Raw/Static',\n      'Cache-Control': 'max-age=300',\n    },\n    body: sanitizer.escape(message),\n  };\n}\n\n/**\n * Generate a `forbidden` response.\n * @returns {object} a response object.\n */\nfunction forbidden() {\n  return {\n    statusCode: 403,\n    headers: {\n      'Content-Type': 'text/plain',\n      'Cache-Control': 'max-age=300', // don't bother us for the next five minutes\n    },\n    body: 'forbidden.',\n  };\n}\n\n/**\n * Checks if the content type is css.\n * @param {string} type - content type\n * @returns {boolean} {@code true} if content type is css.\n */\nfunction isCSS(type) {\n  return type === 'text/css';\n}\n\n/**\n * Checks if the content type is javascript.\n * @param {string} type - content type\n * @returns {boolean} {@code true} if content type is javascript.\n */\nfunction isJavaScript(type) {\n  return /(text|application)\\/(x-)?(javascript|ecmascript)/.test(type);\n}\n\n/**\n * Checks if the content type is binary.\n * @param {string} type - content type\n * @returns {boolean} {@code true} if content type is binary.\n */\nfunction isBinary(type) {\n  if (/text\\/.*/.test(type)) {\n    return false;\n  }\n  if (/.*\\/javascript/.test(type)) {\n    return false;\n  }\n  if (/.*\\/.*json/.test(type)) {\n    return false;\n  }\n  if (/.*\\/.*xml/.test(type)) {\n    return /svg/.test(type); // openwshisk treats svg as binary\n  }\n  return true;\n}\n\n/**\n * Checks if the content type is json.\n * @param {string} type - content type\n * @returns {boolean} {@code true} if content type is json.\n */\nfunction isJSON(type) {\n  return /json/.test(type);\n}\n\n/**\n * Adds general headers to the response.\n * @param {object} headers - The headers object.\n * @param {string} ref - Content ref (branch, tag, or sha)\n * @param {string} content - The response content.\n * @returns {object} the new headers.\n */\nfunction addHeaders(headers, ref, content) {\n  let cacheheaders = {};\n  if (/[a-f0-9]{40}/i.test(ref)) {\n    cacheheaders = {\n      'Cache-Control': 'max-age=131400',\n    };\n  } else if (content) {\n    const hash = crypto.createHash('md5').update(content);\n    cacheheaders = {\n      ETag: `\"${hash.digest('base64')}\"`,\n      'Cache-Control': 's-maxage=300',\n    };\n    if (headers['Content-Type'] && (\n      isCSS(headers['Content-Type'])\n      || isJavaScript(headers['Content-Type'])\n    ) && content.toString().match(/<esi:include/)) {\n      cacheheaders['X-ESI'] = true;\n    }\n  }\n  return Object.assign(headers, cacheheaders);\n}\n\n/**\n * Rewrites the content by replacing all `@import` statements and `url` rules with `<esi:include/>`\n * tags, so that they can be resolved to a stable url by the esi processor.\n *\n * @param {string} css - the css content\n * @param {string} base - the base href\n * @returns {Function | any}\n */\nfunction rewriteCSS(css, base = '') {\n  function rewriteImports(tree) {\n    tree.walkAtRules('import', (rule) => {\n      if (rule.name === 'import') {\n        const [url, queries] = space(rule.params);\n        const parsedurl = parser(url);\n        if (parsedurl.nodes\n          && parsedurl.nodes.length === 1\n          && parsedurl.nodes[0].value === 'url'\n          && parsedurl.nodes[0].nodes\n          && parsedurl.nodes[0].nodes.length === 1\n          && parsedurl.nodes[0].nodes[0].type === 'string'\n          && typeof parsedurl.nodes[0].nodes[0].value === 'string'\n          && typeof parsedurl.nodes[0].nodes[0].quote === 'string') {\n          const importuri = uri.parse(parsedurl.nodes[0].nodes[0].value);\n          const { quote } = parsedurl.nodes[0].nodes[0];\n          if (importuri.reference === 'relative' && !importuri.query) {\n            rule.replaceWith(postcss.atRule({\n              name: 'import',\n              params: `url(${quote}<esi:include src=\"${importuri.path}.url\"/><esi:remove>${importuri.path}</esi:remove>${quote}) ${queries}`,\n            }));\n          }\n        } else if (parsedurl.nodes\n          && parsedurl.nodes[0].type === 'string'\n          && typeof parsedurl.nodes[0].value === 'string'\n          && typeof parsedurl.nodes[0].quote === 'string') {\n          const importuri = uri.parse(parsedurl.nodes[0].value);\n          const { quote } = parsedurl.nodes[0];\n          if (importuri.reference === 'relative' && !importuri.query) {\n            rule.replaceWith(postcss.atRule({\n              name: 'import',\n              params: `${quote}<esi:include src=\"${uri.resolve(base, importuri.path)}.url\"/><esi:remove>${importuri.path}</esi:remove>${quote} ${queries}`,\n            }));\n          }\n        }\n      }\n    });\n    return tree;\n  }\n\n  log.info('rewriting css...');\n  const processor = postcss()\n    .use(rewriteImports)\n    .use(postcssurl({\n      url: (asset) => {\n        // TODO pass in request URL and make it absolute.\n        if (asset.search === '' && asset.absolutePath !== '.' && asset.relativePath !== '.') {\n          return `<esi:include src=\"${uri.resolve(base, asset.relativePath)}.url\"/><esi:remove>${asset.relativePath}</esi:remove>`;\n        }\n        return asset.url;\n      },\n    }));\n  return processor\n    .process(css, { from: undefined })\n    .then(result => result.css)\n    .catch((err) => {\n      log.error('error while processing css', err);\n      return css;\n    });\n}\n\n/**\n * Rewrites the content by replacing all `import` statements rules with `<esi:include/>`\n * tags, so that they can be resolved to a stable url by the esi processor.\n *\n * @param {string} javascript - the javascript content\n * @param {string} base - the base href\n * @returns {Function | any}\n */\nfunction rewriteJavaScript(javascript, base = '') {\n  const importmap = {};\n\n  function rewriteJSImports(bab) {\n    const t = bab.types;\n    return {\n      visitor: {\n        ImportDeclaration(path) {\n          if (path\n            && path.node\n            && path.node.source\n            && path.node.source.value\n            && !importmap[path.node.source.value]) {\n            const srcuri = uri.parse(path.node.source.value);\n            if (srcuri.reference === 'relative' && !srcuri.query) {\n              const { specifiers } = path.node;\n              // console.log(srcuri);\n              const h = ohash(srcuri.path);\n              importmap[h] = `<esi:include src=\"${uri.resolve(base, srcuri.path)}.url\"/><esi:remove>${path.node.source.value}</esi:remove>`;\n              path.replaceWith(t.importDeclaration(specifiers, t.stringLiteral(h)));\n            }\n          }\n          return false;\n        },\n      },\n    };\n  }\n\n  try {\n    log.info('rewriting javascript...');\n    const transformed = babel.transformSync(javascript,\n      { plugins: [rewriteJSImports], retainLines: true });\n\n    return Object.keys(importmap)\n      .reduce((src, key) => src.replace(key, importmap[key]), transformed.code);\n  } catch (e) {\n    log.error('error while processing javascript', e);\n    return javascript;\n  }\n}\n\n/**\n * Processes the body according to the content type.\n * @param {string} type - the content type\n * @param {string} responsebody - the response body\n * @param {boolean} esi - esi flag\n * @param {string} entry - the base href\n * @returns {Function|any|string|any} the response body\n */\nfunction processBody(type, responsebody, esi = false, entry) {\n  if (isBinary(type)) {\n    return Buffer.from(responsebody).toString('base64');\n  }\n  if (isJSON(type)) {\n    return JSON.parse(responsebody);\n  }\n  if (esi && isCSS(type)) {\n    return rewriteCSS(responsebody.toString(), entry);\n  }\n  if (esi && isJavaScript(type)) {\n    return rewriteJavaScript(responsebody.toString(), entry);\n  }\n  return responsebody.toString();\n}\n\n/**\n * Calculates the static base marker.\n * @returns {string}\n */\nfunction staticBase(owner, repo, entry, ref, strain = 'default') {\n  // todo: is this still needed?\n  return `__HLX/${owner}/${repo}/${strain}/${ref}/${entry}/DIST__`;\n}\n\n/**\n * Delivers a plain file from the given github repository.\n *\n * @param owner\n * @param repo\n * @param ref\n * @param entry\n * @param root\n * @param esi\n */\nfunction deliverPlain(owner, repo, ref, entry, root, esi = false) {\n  const cleanentry = (`${root}/${entry}`).replace(/^\\//, '').replace(/[/]+/g, '/');\n  const url = `https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${cleanentry}`;\n  log.info(`deliverPlain: url=${url}`);\n  const rawopts = {\n    url,\n    headers: {\n      'User-Agent': 'Project Helix Static',\n    },\n    resolveWithFullResponse: true,\n    encoding: null,\n  };\n\n  return request.get(rawopts).then(async (response) => {\n    const type = mime.lookup(cleanentry) || 'application/octet-stream';\n    const size = parseInt(response.headers['content-length'], 10);\n    log.info(`got response. size=${size}, type=${type}`);\n    if (size < REDIRECT_LIMIT) {\n      const body = await processBody(type, response.body, esi, entry);\n      log.info(`delivering file ${cleanentry} type ${type} binary: ${isBinary(type)}`);\n      return {\n        statusCode: 200,\n        headers: addHeaders({\n          'Content-Type': type,\n          'X-Static': 'Raw/Static',\n          'X-ESI': esi ? 'enabled' : undefined,\n          'Surrogate-Key': computeSurrogateKey(url),\n        }, ref, response.body),\n        body,\n      };\n    }\n    log.info(`size exceeds limit ${REDIRECT_LIMIT}. sending redirect.`);\n    return {\n      statusCode: 307,\n      headers: {\n        Location: url,\n        'X-Content-Type': type,\n        'X-Static': 'Raw/Static',\n        'Cache-Control': 's-maxage=300',\n        'Surrogate-Key': computeSurrogateKey(url),\n      },\n    };\n  }).catch((rqerror) => {\n    if (esi) {\n      // the ESI failed, so we simply fall back to the original URL\n      // the browser will fetch it again, so let's cache the 404\n      // for five minutes, in order to prevent the static function\n      // from being called too often\n      log.error(`error while fetching content. override status ${rqerror.statusCode} due to esi flag.`);\n      return {\n        statusCode: 404,\n        headers: {\n          'Content-Type': 'text/plain',\n          'Cache-Control': 's-maxage=300',\n        },\n        body: entry,\n      };\n    }\n    if (rqerror.statusCode === 404 || rqerror.statusCode === '404') {\n      return error(entry, rqerror.statusCode);\n    }\n    return error(rqerror.response.body.toString(), rqerror.statusCode);\n  });\n}\n\n/**\n * The blacklist of paths that may never be served\n * @param {*} path\n */\nfunction blacklisted(path, allow, deny) {\n  const whitelist = allow ? new RegExp(allow) : false;\n  const blacklist = deny ? new RegExp(deny) : false;\n\n  if (whitelist) {\n    return !(whitelist.test(path)) || blacklisted(path, undefined, deny);\n  }\n  if (blacklist) {\n    return blacklist.test(path) || blacklisted(path);\n  }\n  if (/^(.*\\/?)package\\.json$/.test(path)) {\n    return true;\n  }\n  if (/^(.*\\/?)helix-config\\.yaml$/.test(path)) {\n    return true;\n  }\n  if (/(^|\\/)\\..+/.test(path)) {\n    return true;\n  }\n  if (/^\\/?src\\//.test(path)) {\n    return true;\n  }\n  return false;\n}\n/**\n *\n * @param {Object} params The OpenWhisk parameters\n * @param {string} params.owner Repository owner on GitHub\n * @param {string} params.repo Repository name on GitHub\n * @param {string} params.ref SHA of a commit or name of a branch or tag on GitHub\n * @param {string} params.path path to the requested file (if used with `entry`)\n * @param {string} params.entry path to the file requested by the browser\n * @param {boolean} params.plain disable asset pre-processing with Parcel\n * @param {string} params.allow regular expression pattern that all delivered files must follow\n * @param {string} params.deny regular expression pattern that all delivered files may not follow\n * @param {string} params.root document root for all static files in the repository\n * @param {boolean} params.esi replace relative URL references in JS and CSS with ESI references\n */\nasync function deliverStatic({\n  owner,\n  repo,\n  ref = 'master',\n  path,\n  entry,\n  strain = 'default',\n  plain = false,\n  allow,\n  deny,\n  root = '',\n  esi = false,\n} = {}) {\n  const file = uri.normalize(entry);\n  log.info(`deliverStatic with ${owner}/${repo}/${ref} path=${path} entry=${entry} file=${file} plain=${plain} allow=${allow} deny=${deny} root=${root} esi=${esi} strain=${strain}`);\n  if (blacklisted(file, allow, deny)) {\n    log.info('blacklisted!');\n    return forbidden();\n  }\n\n  if (plain) {\n    return deliverPlain(owner, repo, ref, file, root, esi);\n  }\n\n  log.info('non-plain is not supported.'); // todo: remove plain parameter?\n  return forbidden();\n}\n\n/**\n * Runs the action by wrapping the `deliverStatic` function with the pingdom-status utility.\n * Additionally, if a EPSAGON_TOKEN is configured, the epsagon tracers are instrumented.\n * @param params Action params\n * @returns {Promise<*>} The response\n */\nasync function run(params) {\n  let action = deliverStatic;\n  if (params && params.EPSAGON_TOKEN) {\n    // ensure that epsagon is only required, if a token is present. this is to avoid invoking their\n    // patchers otherwise.\n    // eslint-disable-next-line global-require\n    const { openWhiskWrapper } = require('epsagon');\n    log.info('instrumenting epsagon.');\n    action = openWhiskWrapper(action, {\n      token_param: 'EPSAGON_TOKEN',\n      appName: 'Helix Services',\n      metadataOnly: false, // Optional, send more trace data\n    });\n  }\n  return wrap(action, {\n    github: 'https://raw.githubusercontent.com/adobe/helix-static/master/src/index.js',\n  })(params);\n}\n\n/**\n * Main function called by the openwhisk invoker.\n * @param params Action params\n * @returns {Promise<*>} The response\n */\nasync function main(params, logger = log) {\n  try {\n    log = setupLogger(params, logger);\n    const result = await run(params);\n    if (log.flush) {\n      log.flush(); // don't wait\n    }\n    return result;\n  } catch (e) {\n    console.error(e);\n    return {\n      statusCode: e.statusCode || 500,\n    };\n  }\n}\n\n// todo: do we still need those exports?\nmodule.exports = {\n  error,\n  addHeaders,\n  isBinary,\n  staticBase,\n  blacklisted,\n  getBody: processBody,\n  main,\n};\n"
          },
          "cookies": [],
          "headers": [
            {
              "name": "content-security-policy",
              "value": "default-src 'none'; style-src 'unsafe-inline'; sandbox"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=31536000"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-frame-options",
              "value": "deny"
            },
            {
              "name": "x-xss-protection",
              "value": "1; mode=block"
            },
            {
              "name": "etag",
              "value": "\"86a1314fd0c170c8d6bff3dd1dcc42f35bca6c63\""
            },
            {
              "name": "content-type",
              "value": "text/plain; charset=utf-8"
            },
            {
              "name": "cache-control",
              "value": "max-age=300"
            },
            {
              "name": "x-geo-block-list",
              "value": ""
            },
            {
              "name": "x-github-request-id",
              "value": "DBDE:6439:5071D:5A1AF:5D3B62C6"
            },
            {
              "name": "content-length",
              "value": "15798"
            },
            {
              "name": "accept-ranges",
              "value": "bytes"
            },
            {
              "name": "date",
              "value": "Fri, 26 Jul 2019 20:29:59 GMT"
            },
            {
              "name": "via",
              "value": "1.1 varnish"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "x-served-by",
              "value": "cache-lax8648-LAX"
            },
            {
              "name": "x-cache",
              "value": "MISS"
            },
            {
              "name": "x-cache-hits",
              "value": "0"
            },
            {
              "name": "x-timer",
              "value": "S1564172999.493882,VS0,VE166"
            },
            {
              "name": "vary",
              "value": "Authorization,Accept-Encoding"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "x-fastly-request-id",
              "value": "5e7194e3162bb859a0161b37fca77dc2f4c12cd7"
            },
            {
              "name": "expires",
              "value": "Fri, 26 Jul 2019 20:34:59 GMT"
            },
            {
              "name": "source-age",
              "value": "0"
            }
          ],
          "headersSize": 818,
          "httpVersion": "HTTP/1.1",
          "redirectURL": "",
          "status": 200,
          "statusText": "OK"
        },
        "startedDateTime": "2019-07-26T20:29:59.289Z",
        "time": 420,
        "timings": {
          "blocked": -1,
          "connect": -1,
          "dns": -1,
          "receive": 0,
          "send": 0,
          "ssl": -1,
          "wait": 420
        }
      }
    ],
    "pages": [],
    "version": "1.2"
  }
}
